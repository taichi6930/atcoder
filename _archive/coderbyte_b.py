# 数列 `S[0]` を以下のように定義する（m は入力として与えられた偶数）：
# S[0] = (0, 1, ..., m - 1)
# また、`n=1,2,...`に対して、数列S[n]を以下のように定義する：
# S[n] = shuffle(S[n - 1] + S[n - 1])

# ここで、`+`はシーケンスの連結を表し、`shuffle(...)`は、まず先頭から偶数のインデックスを持つ要素を取り出し、次に先頭から奇数のインデックスを持つ要素を取り出して新しいシーケンスを作成することを意味する。シーケンスの添字は0添字であることに注意。例えば、`shuffle(0,1,2,3,4,5) = (0,2,4,1,3,5)`となる。

# 例えば、m=4の時
# S[0]=(0,1,2,3)
# S[1]=shuffle(0,1,2,3,0,1,2,3)=(0,2,0,2,1,3,1,3)
# S[2]=shuffle(0,2,0,2,1,3,1,3,0,2,0,2,1,3,1,3)=(0,0,1,1,0,0,1,1,2,2,3,3,2,2,3,3)

#  整数 n, m, a, b が与えられたとき、
# 配列 `S[n]` の a 番目の要素から b 番目の要素までの部分列を求め、出力しなさい。
# 入力サイズが小さい場合と大きい場合の両方で、あなたのコードを評価します。
# あなたのコードの計算時間をできるだけ最適化してください。
# 望ましい計算時間は `O(n(b-a))` である。
# 上記の計算時間内でアルゴリズムを構成することが困難な場合は、
# `n<=20` の入力に対して現実的な計算時間内で問題を解くことができるコードを提出してください。
# どのプログラミング言語を使用してもよい。ただ、以下のメソッド/関数を確実に実装してください。

# 例えば、n=0, m=4, a=0, b=3の時、
# S[0]=(0,1,2,3)
# S[1]=(0,2,0,2,1,3,1,3)
# S[2]=sufflue(0,2,0,2,1,3,1,3)(0,2,0,2,1,3,1,3)


# S[2]=(0,0,1,1,0,0,1,1,2,2,3,3,2,2,3,3)
# S[3]=(0,1,0,1,2,3,2,3,0,1,0,1,2,3,2,3,0,1,0,1,2,3,2,3,0,1,0,1,2,3,2,3)
# S[4]=(0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,0,0,2,2,1,1,3,3,1,1,3,3,1,1,3,3,1,1,3,31,1,3,3,1,1,3,3,1,1,3,3,1,1,3,3)


def solve(n: int, m: int, a: int, b: int) -> list[int]:
    for num in range(a, b + 1):
        _num = num
        for _n in range(n):
            # numの先祖を知りたい
            # numが前25%〜50%の場合、すべての長さの1/4の要素を引く

    # n = 20までの場合
    S = [i for i in range(m)]
    for i in range(n):
        S = S[0::2] * 2 + S[1::2] * 2

    return S[a : b + 1]



print(solve(34, 30, 123456789012, 123456789031))
